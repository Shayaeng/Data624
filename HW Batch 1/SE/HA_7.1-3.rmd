---
title: "HA Chapter 7 #1-3"
author: "Group 3"
date: "2024-06-07"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=F}
library(fpp2)
library(forecast)
```

# Prompt

Consider the pigs series --- the number of pigs slaughtered in Victoria each month.

-   **7.1 (a)** Use the `ses()` function in R to find the optimal values of $\alpha$ and $\ell_0$, and generate forecasts for the next four months.
-   **7.1 (b)** Compute a 95% prediction interval for the first forecast using $\hat{y} \pm 1.96s$ where $s$ is the standard deviation of the residuals. Compare your interval with the interval produced by R.
-   **7.2** Write your own function to implement simple exponential smoothing. The function should take arguments `y` (the time series), `alpha` (the smoothing parameter $\alpha$) and `level` (the initial level $\ell_0$). It should return the forecast of the next observation in the series. Does it give the same forecast as `ses()`?
-   **7.3** Modify your function from the previous exercise to return the sum of squared errors rather than the forecast of the next observation. Then use the `optim()` function to find the optimal values of $\alpha$ and $\ell_0$. Do you get the same values as the `ses()` function?


## Simple Exponential Smoothing

### Forecasts

```{r}
# Use the ses() function to find optimal values and generate forecasts
fit <- ses(pigs, h = 4)

# Extracting the optimal parameters
alpha_opt <- fit$model$par["alpha"]
level_opt <- fit$model$par["l"]

# Print the results
#print(fit)
cat("Optimal alpha:", alpha_opt, "\n")
cat("Optimal level (l0):", level_opt, "\n")

# Forecasts for the next 4 months
forecasts <- fit$mean
print(forecasts)
```

The optimum alpha for the simple exponential smoothing is 0.297 and the optimum level is 77260.06. Using these values, the ses() function generated forecasts for the next four months. The forecasts were all 98816.41. 

A feature of simple exponential smoothing is that the forecast for the next period is equal to the level of the series at the current period. Therefore, all future months will have the same forecast, albeit with wider successive prediction intervals.

### Prediction Interval

```{r}
# Standard deviation of the residuals
s <- sd(residuals(fit))

# First forecast
first_forecast <- forecasts[1]

# 95% prediction interval
lower_bound <- first_forecast - 1.96 * s
upper_bound <- first_forecast + 1.96 * s
man_ci_95 <- c(lower_bound, upper_bound)

# Compare with interval produced by R
lower_95_first <- fit$lower[1, "95%"]
upper_95_first <- fit$upper[1, "95%"]
ses_ci_95 <- c(lower_95_first, upper_95_first)

cat("95% prediction interval (manual):", man_ci_95, "\n")
cat("95% prediction interval (ses()):", ses_ci_95, "\n")
```

The 95% prediction interval for the first forecast using the manual calculation is (78679.97-118952.8), while the interval produced by the ses() function is (78611.97-119020.8). The discrepancy is likely due to the rounding of the standard deviation, the inexactness of the 1.96 multiplier, the specific implementation of the ses() function, floating-point errors, or a combination of these factors. The intervals are close enough to be considered equivalent for practical purposes.

### Simple Exponential Smoothing Custom Function

```{r}
# Function for simple exponential smoothing
simple_exponential_smoothing <- function(y, alpha, level) {
  n <- length(y)
  forecast <- numeric(n + 1)
  forecast[1] <- level
  
  for (t in 1:n) {
    forecast[t + 1] <- alpha * y[t] + (1 - alpha) * forecast[t]
  }
  
  return(forecast[n + 1])
}

# Compare with ses() forecast
my_forecast <- simple_exponential_smoothing(pigs, alpha_opt, level_opt)
cat("My forecast:", my_forecast, "\n")
cat("ses() forecast:", forecasts[1], "\n")
```

The custom function for simple exponential smoothing produced a forecast of 98816.41, which is the same as the forecast generated by the ses() function. This result confirms that the custom function is correctly implementing simple exponential smoothing. It should be noted that the alpha and level parameters used in the custom function are the optimal values obtained from the ses() function. This means that while the custom function can produce the same forecast as ses(), while using the same parameters, it is still dependent on the ses() function for the optimal values.

### Sum of Squared Errors and Optimization

```{r}
# Function for simple exponential smoothing returning sum of squared errors
simple_exponential_smoothing_sse <- function(y, alpha, level) {
  n <- length(y)
  forecasts <- numeric(n)
  forecasts[1] <- level
  sse <- 0
  
  for (t in 2:n) {
    forecasts[t] <- alpha * y[t-1] + (1 - alpha) * forecasts[t-1]
    sse <- sse + (y[t] - forecasts[t])^2
  }
  
  return(sse)
}

# Use the optim() function to find the optimal alpha and level
initial_params <- c(alpha = 0.2, level = pigs[1])
optim_result <- optim(initial_params, function(params) {
  simple_exponential_smoothing_sse(pigs, params[1], params[2])
})

optimal_alpha <- optim_result$par[1]
optimal_level <- optim_result$par[2]

cat("Optimized alpha:", optimal_alpha, "\n")
cat("Optimized level:", optimal_level, "\n")

# Compare with ses() optimal values
cat("ses() alpha:", alpha_opt, "\n")
cat("ses() level:", level_opt, "\n")
```

The optimization process using the `optim()` function found an optimal alpha of 0.2971488 and an optimal level of 77260.06. These values are extremely similar to the optimal values obtained from the ses() function. This result indicates that the custom function, which minimizes the sum of squared errors, can find the same optimal values for alpha and level as the ses() function. The similarity in the optimal values further confirms the accuracy of the custom function in implementing simple exponential smoothing.